// ============================================
// FILE: gemini-mcp-client.js  
// The Gemini Client (Frontend AI that connects to MCP server)
// ============================================

import express from 'express';
import cors from 'cors';
import axios from 'axios';
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';

// Get current directory for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

console.log('üöÄ [GEMINI-CLIENT] Starting Gemini MCP Client...');
console.log('üîë [GEMINI-CLIENT] API Key configured:', GEMINI_API_KEY ? 'Yes' : 'No');
console.log('üìÅ [GEMINI-CLIENT] Current directory:', __dirname);

app.use(cors());
app.use(express.json());

// Initialize MCP Client
let mcpClient = null;
let mcpTransport = null;
let isConnected = false;

async function initializeMcpClient() {
  console.log('üîß [GEMINI-CLIENT] Initializing MCP Client...');
  
  try {
    // Create client instance
    mcpClient = new Client({
      name: "gemini-mcp-client",
      version: "1.0.0"
    }, {
      capabilities: {
        tools: {}
      }
    });
    
    console.log('‚úÖ [GEMINI-CLIENT] Client instance created');

    // Create transport to MCP server - using full path to the file in same directory
    const mcpServerPath = path.join(__dirname, 'mcp-multi-tool-server.js');
    console.log('üìÅ [GEMINI-CLIENT] MCP Server path:', mcpServerPath);
    
    mcpTransport = new StdioClientTransport({
      command: "node",
      args: [mcpServerPath],
      env: process.env
    });
    
    console.log('üîß [GEMINI-CLIENT] Transport created, connecting to MCP server...');

    // Connect to MCP server
    await mcpClient.connect(mcpTransport);
    isConnected = true;
    console.log('üîó [GEMINI-CLIENT] Connected to MCP server successfully!');
    
    // List available tools
    try {
      const { tools } = await mcpClient.listTools();
      const toolNames = tools.map(t => t.name);
      
      console.log(`üõ†Ô∏è [GEMINI-CLIENT] ${toolNames.length} MCP tools available: ${toolNames.join(', ')}`);
    } catch (toolListError) {
      console.error('‚ö†Ô∏è [GEMINI-CLIENT] Could not list tools:', toolListError.message);
    }

    return true;
  } catch (error) {
    console.error('‚ùå [GEMINI-CLIENT] Failed to initialize MCP client:', error.message);
    console.error('üîç [GEMINI-CLIENT] Error details:', error.stack);
    isConnected = false;
    return false;
  }
}

// Initialize on startup
initializeMcpClient().then(success => {
  if (success) {
    console.log('‚úÖ [GEMINI-CLIENT] MCP client initialized successfully at startup');
  } else {
    console.error('‚ùå [GEMINI-CLIENT] Failed to initialize MCP client at startup');
  }
});

async function callGemini(prompt, toolsContext = '') {
  console.log('ü§ñ [GEMINI-CLIENT] Calling Gemini API...');
  console.log('üìù [GEMINI-CLIENT] Prompt length:', prompt.length);
  
  try {
    const fullPrompt = prompt + (toolsContext ? `\n\n${toolsContext}` : '');
    console.log('üì§ [GEMINI-CLIENT] Sending request to Gemini...');
    
    // üìã LOG: JSON REQUEST TO GEMINI
    const geminiRequestPayload = {
      contents: [{ 
        role: 'user', 
        parts: [{ text: fullPrompt }] 
      }]
    };
    console.log('üìã [FLOW-LOG] JSON REQUEST TO GEMINI:');
    console.log(JSON.stringify(geminiRequestPayload, null, 2));
    
    const response = await axios.post(
      `https://generativelanguage.googleapis.com/v1/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`,
      geminiRequestPayload,
      { headers: { 'Content-Type': 'application/json' } }
    );

    // üìã LOG: GEMINI RESPONSE JSON
    console.log('üìã [FLOW-LOG] GEMINI RESPONSE JSON:');
    console.log(JSON.stringify(response.data, null, 2));

    const result = response.data?.candidates?.[0]?.content?.parts?.[0]?.text || 'No response from Gemini.';
    console.log('‚úÖ [GEMINI-CLIENT] Gemini API response received');
    console.log('üìù [GEMINI-CLIENT] Response length:', result.length);
    
    // üìã LOG: EXTRACTED TEXT FROM GEMINI
    console.log('üìã [FLOW-LOG] EXTRACTED TEXT FROM GEMINI:');
    console.log(result);
    
    return result;
  } catch (error) {
    console.error('‚ùå [GEMINI-CLIENT] Gemini API Error:', error.message);
    if (error.response) {
      console.error('üîç [GEMINI-CLIENT] Response status:', error.response.status);
      console.error('üîç [GEMINI-CLIENT] Response data:', error.response.data);
    }
    throw new Error('Failed to communicate with Gemini API');
  }
}

function formatToolsForPrompt(tools) {
  return tools.map((tool, index) => {
    const params = tool.inputSchema?.properties ? 
      Object.entries(tool.inputSchema.properties).map(([key, value]) => 
        `"${key}": "${value.description || value.type}"`
      ).join(', ') : 'no parameters';
    
    return `${index + 1}. "${tool.name}" - ${tool.description} - Parameters: {${params}}`;
  }).join('\n');
}

// Main chat endpoint
app.post('/chat', async (req, res) => {
  const { prompt } = req.body;
  console.log('\nüîÑ [GEMINI-CLIENT] New chat request received');
  console.log('üìù [GEMINI-CLIENT] Prompt:', prompt);
  
  // üìã LOG: USER REQUEST RECEIVED
  console.log('üìã [FLOW-LOG] 1Ô∏è‚É£ USER REQUEST RECEIVED:');
  console.log(JSON.stringify(req.body, null, 2));
  
  if (!prompt) {
    console.error('‚ùå [GEMINI-CLIENT] No prompt provided');
    return res.status(400).json({ error: 'Prompt is required' });
  }

  if (!GEMINI_API_KEY) {
    console.error('‚ùå [GEMINI-CLIENT] Gemini API key not configured');
    return res.status(500).json({ error: 'Gemini API key not configured' });
  }

  try {
    // Ensure MCP client is connected
    if (!isConnected || !mcpClient) {
      console.log('üîÑ [GEMINI-CLIENT] MCP client not connected, attempting to reconnect...');
      const initialized = await initializeMcpClient();
      if (!initialized) {
        console.error('‚ùå [GEMINI-CLIENT] Failed to connect to MCP server');
        return res.status(500).json({ error: 'MCP client not available' });
      }
    }

    // Get available tools dynamically
    console.log('üìã [GEMINI-CLIENT] Fetching available tools dynamically...');
    let tools = [];
    try {
      const toolsResponse = await mcpClient.listTools();
      tools = toolsResponse.tools || [];
      console.log('‚úÖ [GEMINI-CLIENT] Tools fetched successfully:', tools.length);
      console.log('üîß [GEMINI-CLIENT] Available tools:', tools.map(t => t.name).join(', '));
    } catch (toolsError) {
      console.error('‚ö†Ô∏è [GEMINI-CLIENT] Could not fetch tools:', toolsError.message);
    }

    // If no tools available, go to general conversation
    if (tools.length === 0) {
      console.log('üí¨ [GEMINI-CLIENT] No tools available, processing as general conversation...');
      
      // üìã LOG: GENERAL CONVERSATION
      console.log('üìã [FLOW-LOG] 2Ô∏è‚É£ GENERAL CONVERSATION - SENDING TO GEMINI:');
      console.log('Prompt:', prompt);
      
      const answer = await callGemini(prompt);
      console.log('‚úÖ [GEMINI-CLIENT] General conversation completed');
      
      // üìã LOG: FINAL RESPONSE TO USER
      console.log('üìã [FLOW-LOG] 3Ô∏è‚É£ FINAL RESPONSE TO USER:');
      console.log('Final response:', answer);
      
      return res.json({ response: answer });
    }

    // ============================================
    // üîß DYNAMIC TOOL SELECTION
    // ============================================
    console.log('üîß [GEMINI-CLIENT] Processing request with dynamic tool selection...');
    
    const toolsFormatted = formatToolsForPrompt(tools);
    const toolSelectionPrompt = `
You are an intelligent assistant that can use tools to help users. Based on the user's request, decide whether to use a tool or respond directly.

User request: "${prompt}"

Available tools:
${toolsFormatted}

Instructions:
1. If the user's request can be fulfilled with one of the available tools, respond with EXACTLY this JSON format:
   {
     "type": "tool_use",
     "name": "tool-name",
     "id": "tool-${Date.now()}",
     "input": {
       "param1": "value1",
       "param2": "value2"
     }
   }

2. If no tool is needed or suitable, respond with this JSON format and provide your actual answer:
   {
     "type": "text",
     "text": "Your actual answer to the user's question here"
   }

3. Make sure the tool name matches exactly one of the available tools
4. Include all required parameters in the "input" object as specified in the tool description
5. Use appropriate values for the parameters based on the user's request
6. Always include a unique "id" field with format "tool-{timestamp}"
7. For text responses, provide the actual helpful answer to the user's question, not a placeholder

Choose the most appropriate action:`;

    console.log('ü§ñ [GEMINI-CLIENT] Getting tool selection decision from Gemini...');
    
    // üìã LOG: HOST PROCESSING DECISION
    console.log('üìã [FLOW-LOG] 2Ô∏è‚É£ HOST PROCESSING FOR DECISION - SENDING TO GEMINI:');
    console.log('Available tools sent to Gemini:');
    console.log(toolsFormatted);
    
    const toolDecision = await callGemini(toolSelectionPrompt);
    console.log('üîç [GEMINI-CLIENT] Tool Decision Raw:', toolDecision);
    
    // üìã LOG: GEMINI DECISION RESPONSE
    console.log('üìã [FLOW-LOG] 3Ô∏è‚É£ GEMINI DECISION RESPONSE:');
    console.log('Decision received from Gemini:', toolDecision);

    try {
      // Clean up the response to extract JSON
      let jsonStr = toolDecision.trim();
      if (jsonStr.includes('```json')) {
        jsonStr = jsonStr.split('```json')[1].split('```')[0].trim();
      } else if (jsonStr.includes('```')) {
        jsonStr = jsonStr.split('```')[1].split('```')[0].trim();
      }
      
      const decision = JSON.parse(jsonStr);
      console.log('üîß [GEMINI-CLIENT] Parsed tool decision:', decision);
      
      // üìã LOG: PARSED DECISION
      console.log('üìã [FLOW-LOG] 3Ô∏è‚É£ PARSED DECISION JSON:');
      console.log(JSON.stringify(decision, null, 2));

      // Check if it's a tool_use type
      if (decision.type === 'tool_use' && decision.name) {
        // Verify tool exists
        const selectedTool = tools.find(t => t.name === decision.name);
        if (!selectedTool) {
          console.error('‚ùå [GEMINI-CLIENT] Selected tool not found:', decision.name);
          console.log('üí¨ [GEMINI-CLIENT] Falling back to general conversation...');
        } else {
          console.log('üîß [GEMINI-CLIENT] Executing selected tool:', decision.name);
          
          // üìã LOG: TOOL CALL
          console.log('üìã [FLOW-LOG] 4Ô∏è‚É£ CALLING MCP TOOL:');
          console.log('Tool name:', decision.name);
          console.log('Tool ID:', decision.id);
          console.log('Tool arguments:', JSON.stringify(decision.input || {}, null, 2));
          
          const result = await mcpClient.callTool({ 
            name: decision.name, 
            arguments: decision.input || {} 
          });
          console.log('‚úÖ [GEMINI-CLIENT] Tool execution completed');
          
          // üìã LOG: TOOL RESPONSE
          console.log('üìã [FLOW-LOG] 5Ô∏è‚É£ TOOL RESPONSE RECEIVED:');
          console.log(JSON.stringify(result, null, 2));
          
          // üìã LOG: SENDING BACK TO GEMINI FOR EXPLANATION
          const explanationPrompt = `User asked: "${prompt}"\n\nTool "${decision.name}" (ID: ${decision.id}) was executed with parameters: ${JSON.stringify(decision.input || {})}\n\nTool result:\n${result.content[0].text}\n\nProvide a helpful explanation of what was accomplished and any relevant details for the user.`;
          console.log('üìã [FLOW-LOG] 6Ô∏è‚É£ SENDING TOOL RESULT TO GEMINI FOR EXPLANATION:');
          console.log('Explanation prompt length:', explanationPrompt.length);
          
          const explanation = await callGemini(explanationPrompt);
          
          // üìã LOG: FINAL RESPONSE TO USER
          console.log('üìã [FLOW-LOG] 7Ô∏è‚É£ FINAL RESPONSE TO USER:');
          console.log('Final response:', explanation);
          
          return res.json({ response: explanation });
        }
      }
      // Check if it's a direct text response
      else if (decision.type === 'text') {
        console.log('üí¨ [GEMINI-CLIENT] Gemini chose to respond directly without tools');
        
        // üìã LOG: DIRECT RESPONSE
        console.log('üìã [FLOW-LOG] 3Ô∏è‚É£ DIRECT RESPONSE FROM GEMINI:');
        console.log('Direct response:', decision.text);
        
        return res.json({ response: decision.text });
      }
      // If Gemini didn't follow the format, treat the whole response as text
      else {
        console.log('üí¨ [GEMINI-CLIENT] Gemini response not in expected format, using raw response');
        
        // üìã LOG: RAW RESPONSE
        console.log('üìã [FLOW-LOG] 3Ô∏è‚É£ RAW RESPONSE FROM GEMINI:');
        console.log('Raw response:', toolDecision);
        
        return res.json({ response: toolDecision });
      }
    } catch (parseError) {
      console.log('üîÑ [GEMINI-CLIENT] Tool decision parsing failed, trying general conversation');
      console.error('üîç [GEMINI-CLIENT] Parse error:', parseError.message);
    }

    // ============================================
    // üí¨ GENERAL CONVERSATION (Fallback)
    // ============================================
    console.log('üí¨ [GEMINI-CLIENT] Processing as general conversation...');
    const toolsContext = `Available tools if needed:\n- ${tools.map(t => `${t.name}: ${t.description}`).join('\n- ')}`;
    
    // üìã LOG: GENERAL CONVERSATION
    console.log('üìã [FLOW-LOG] 2Ô∏è‚É£ GENERAL CONVERSATION - SENDING TO GEMINI:');
    console.log('Prompt with tools context length:', (prompt + '\n\n' + toolsContext).length);
    
    const answer = await callGemini(prompt, toolsContext);
    console.log('‚úÖ [GEMINI-CLIENT] General conversation completed');
    
    // üìã LOG: FINAL RESPONSE TO USER
    console.log('üìã [FLOW-LOG] 3Ô∏è‚É£ FINAL RESPONSE TO USER:');
    console.log('Final response:', answer);
    
    return res.json({ response: answer });

  } catch (err) {
    console.error('‚ùå [GEMINI-CLIENT] Error in chat endpoint:', err.message);
    console.error('üîç [GEMINI-CLIENT] Error stack:', err.stack);
    return res.status(500).json({ 
      error: 'Internal server error', 
      details: err.message 
    });
  }
});

// Health check endpoint
app.get('/health', async (req, res) => {
  console.log('üè• [GEMINI-CLIENT] Health check requested');
  
  try {
    if (!isConnected || !mcpClient) {
      console.log('‚ö†Ô∏è [GEMINI-CLIENT] MCP client not connected');
      return res.status(503).json({ 
        status: 'MCP client not connected',
        mcpConnected: false,
        geminiConfigured: !!GEMINI_API_KEY
      });
    }
    
    const { tools } = await mcpClient.listTools();
    console.log('‚úÖ [GEMINI-CLIENT] Health check passed');
    
    res.json({ 
      status: 'healthy', 
      mcpConnected: true,
      geminiConfigured: !!GEMINI_API_KEY,
      availableTools: tools.length,
      tools: tools.map(t => t.name)
    });
  } catch (error) {
    console.error('‚ùå [GEMINI-CLIENT] Health check failed:', error.message);
    res.status(503).json({ 
      status: 'unhealthy', 
      mcpConnected: false,
      geminiConfigured: !!GEMINI_API_KEY,
      error: error.message 
    });
  }
});

// Test endpoint for debugging
app.get('/test-mcp', async (req, res) => {
  console.log('üß™ [GEMINI-CLIENT] MCP test requested');
  
  try {
    if (!isConnected || !mcpClient) {
      const initialized = await initializeMcpClient();
      if (!initialized) {
        return res.status(500).json({ error: 'Cannot connect to MCP server' });
      }
    }
    
    const { tools } = await mcpClient.listTools();
    console.log('‚úÖ [GEMINI-CLIENT] MCP test passed');
    
    res.json({
      message: 'MCP connection test successful',
      tools: tools.map(t => ({ name: t.name, description: t.description }))
    });
  } catch (error) {
    console.error('‚ùå [GEMINI-CLIENT] MCP test failed:', error.message);
    res.status(500).json({ error: error.message });
  }
});

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('\nüõë [GEMINI-CLIENT] Shutting down gracefully...');
  if (mcpTransport) {
    console.log('üîå [GEMINI-CLIENT] Closing MCP transport...');
    try {
      await mcpTransport.close();
      console.log('‚úÖ [GEMINI-CLIENT] MCP transport closed');
    } catch (error) {
      console.error('‚ùå [GEMINI-CLIENT] Error closing transport:', error.message);
    }
  }
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('\nüõë [GEMINI-CLIENT] Received SIGTERM, shutting down gracefully...');
  if (mcpTransport) {
    try {
      await mcpTransport.close();
    } catch (error) {
      console.error('‚ùå [GEMINI-CLIENT] Error closing transport:', error.message);
    }
  }
  process.exit(0);
});

// Start server
app.listen(PORT, () => {
  console.log(`üöÄ [GEMINI-CLIENT] Server running on http://localhost:${PORT}`);
  console.log(`üí¨ [GEMINI-CLIENT] Chat endpoint: POST http://localhost:${PORT}/chat`);
  console.log(`üè• [GEMINI-CLIENT] Health check: GET http://localhost:${PORT}/health`);
  console.log(`üß™ [GEMINI-CLIENT] MCP test: GET http://localhost:${PORT}/test-mcp`);
  console.log(`üîë [GEMINI-CLIENT] Environment: ${process.env.NODE_ENV || 'development'}`);
});